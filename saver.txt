class Pqueue {

    private:

        vector<double> heapQueue;
        int size;

    public:

        Pqueue() {
            size = 0;
        }

        //Function to insert an element into the Min heap priority quueu

        void insert(double value) {

            heapQueue.push_back(value);
            size++;

            int currentIndex = size - 1;

            while (currentIndex > 0) {

                int parentIndex = (currentIndex - 1) / 2;

                if (heapQueue[currentIndex] < heapQueue[parentIndex]) {

                    swap(heapQueue[currentIndex], heapQueue[parentIndex]);

                    currentIndex = parentIndex;

                } else {

                    break;

                }
            }
        }

        //Function to remove and return the minimum element from the Min heap priority queue
        double getTop() {

            if (size == 0) {

                cout<<"Priority Queue is empty" <<endl;

                return -1;

            }

            double top = heapQueue[0];

            heapQueue[0] = heapQueue[size - 1];

            heapQueue.pop_back();

            size--;

            int currentIndex = 0;



            while (true) {


                int leftChildIndex = 2 * currentIndex + 1;
                int rightChildIndex = 2 * currentIndex + 2;
                int smallestIndex = currentIndex;

                if (leftChildIndex < size && heapQueue[leftChildIndex] < heapQueue[smallestIndex]) {

                    smallestIndex = leftChildIndex;

                }

                if (rightChildIndex < size && heapQueue[rightChildIndex] < heapQueue[smallestIndex]) {

                    smallestIndex = rightChildIndex;

                }

                if (smallestIndex != currentIndex) {

                    swap(heapQueue[currentIndex], heapQueue[smallestIndex]);

                    currentIndex = smallestIndex;

                } 
                else {

                    break;
                }



            }

            return top;
        }

        int getSize() {

            return size;

        }
    

        

};



truct Node {
    int arrivalTime;
    int burstTime;
    string name;
};

double generateInterval(int lambda, int mu, int M, int numOfEvents){
    

}


class FifoQueue {
    private:
        vector <double> fifoQueue;
    public:
      
        void insert(double value) {
            fifoQueue.push_back(value);

        }



        double takeTop() {
            if (fifoQueue.empty()) {
                cout<<"FIFO Queue is empty" <<endl;
                return -1;
            }
            double top = fifoQueue.front();
            fifoQueue.erase(fifoQueue.begin());
            return top;

        }
        int getSize() {
            return fifoQueue.size();
        }

};



int main () {


    srand(time(0));

    double totalTime=0;
    int totalServersAvailable=2;
    int processesCompleted=0;

    cout<< "Hello World!" << endl;

    FifoQueue fifo;
    Pqueue priorityQueue;

    double time=0;

    // Idle time tracking variables
    double totalIdleTime = 0.0;
    double lastEventTime = 0.0;
    int totalServers = 2;
    int serversIdle = totalServers;

    while(processesCompleted!=numProcesses) {

        if (priorityQueue.getSize() <M+1){

            for (int i=priorityQueue.getSize(); i<200; i++){

                double arrivalTime=generateArrivalTime(time);

                // Store arrival time in Event

                priorityQueue.insert(Event{arrivalTime, 0});

                time=arrivalTime;

                
            }
        }

        // ARRIVAL EVENT, server available
        if (priorityQueue.peekTop().type==0 && totalServersAvailable>0){

            // If servers were idle, accumulate idle time
            if (serversIdle > 0) {

                totalIdleTime += (priorityQueue.peekTop().time - lastEventTime) * serversIdle;

            }
            serversIdle--;

            Event arrivalEvent= priorityQueue.getTop();

            // Store arrival time for this process
            double arrivalTime = arrivalEvent.time;

            double departureTime = generateDepartureTime(arrivalTime);

            // Store arrival time in departure event

            priorityQueue.insert(Event{departureTime, 1, arrivalTime});

            totalServersAvailable--;
            
            lastEventTime = arrivalEvent.time;
            
            time=arrivalEvent.time;
            totalTimeInSystem+= departureTime - arrivalTime;

        }
        // ARRIVAL EVENT, no server available
        else if (priorityQueue.peekTop().type==0 && totalServersAvailable==0){

            Event arrivalEvent= priorityQueue.getTop();

            fifo.insert(arrivalEvent);

            lastEventTime = arrivalEvent.time;

            time=arrivalEvent.time;
            
        }

        // DEPARTURE EVENT
        else if (priorityQueue.peekTop().type==1){



            Event departureEvent= priorityQueue.getTop();

            serversIdle++;

            totalServersAvailable++;

            processesCompleted++;

            cout<<"Process "<< processesCompleted <<" completed at time "<< departureEvent.time <<endl;

            lastEventTime = departureEvent.time;

            time=departureEvent.time;

            // Calculate time spent in system for this process

           

            // Calculate time waited in queue for this process
           


            if (fifo.getSize()>0){

                Event fifoEvent = fifo.takeTop();

                double arrivalTime = fifoEvent.time;

                double departureTime = generateDepartureTime(time);

                priorityQueue.insert(Event{departureTime, 1, arrivalTime});

                serversIdle--;

                totalServersAvailable--;

            }
        }
    }

    // If servers are idle at the end, accumulate their final idle time
    if (serversIdle > 0) {

        totalIdleTime += (time - lastEventTime) * serversIdle;

    }

    double percentIdle = (totalIdleTime / (time * totalServers)) * 100.0;

    double averageTimeInSystem = totalTimeInSystem / numProcesses;

    double averageTimeWaited = totalTimeWaited / numProcesses;

    cout << "Done!" << endl;
    cout << "Percent idle time: " << percentIdle << "%" << endl;
    cout << "Average time in system: " << averageTimeInSystem << " units" << endl;
    cout << "Average time waited: " << averageTimeWaited << " units" << endl;

    Event testEvent{10.5, 0, 5.0, -1};
    cout << "Test Event - Time: " << testEvent.time << ", Type: " << testEvent.type << ", Arrival Time: " << testEvent.arrivalTime << ", Departure Time:" << testEvent.departureTime << endl;

    return 0;
}
