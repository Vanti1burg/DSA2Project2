#include <iostream>
#include <string>
#include <ctime>
#include <vector>
#include <fstream>
#include <algorithm>
#include <random>
#include <sstream>

#include "Pqueue.hpp"
#include "FifoQueue.hpp"

using namespace std;


    int lambda =2;
    int numProcesses= 5000;
    int mu= 3;
    int M= 2;

    // For idle time tracking
    double totalIdleTime = 0.0;
    double lastEventTime = 0.0;
    double totalTimeInSystem=0.0;
    int totalServers = 2;
    int serversIdle = totalServers;
    double totalTimeWaited=0;


    double generateArrivalTime(double timeAlreadyPassed) {

        double time= timeAlreadyPassed;
        double avg=1.0/lambda;
        double arrivalTime = -avg * log(1.0 - (rand() / (RAND_MAX + 1.0)));
        return arrivalTime+time;

    }




    double generateDepartureTime(double timeAlreadyPassed) {

        double avg=1.0/mu;
        double timePassed= timeAlreadyPassed;
        double serviceInterval = -avg * log(1.0 - (rand() / (RAND_MAX + 1.0)));
        double departureTime=serviceInterval + timePassed;
        return departureTime;

    }

    

    int main () {

        srand(time(0));
        Pqueue priorityQueue;
        FifoQueue fifo;

        int processesCompleted=0;
        int totalServersAvailable=M;
        double time=0.0;

        double totalTimeInSystem=0.0;
        double totalTimeWaited=0.0;
        int serversIdle=totalServersAvailable;
        double totalIdleTime=0.0;
        double lastEventTime=0.0;

        while(processesCompleted < numProcesses) {
            
            if (priorityQueue.getSize() <=M+1){
                for (int i=priorityQueue.getSize(); i<200;i++){
                    Event newEvent;
                    newEvent.time=generateArrivalTime(time);
                    newEvent.type=0;
                    newEvent.arrivalTime=newEvent.time;
                    priorityQueue.insert(newEvent);
                    time=newEvent.time;
                }

            }
            
            if (priorityQueue.peekTop().type==0 && totalServersAvailable>0){

                
                Event arrivalEvent = priorityQueue.getTop();
                time=arrivalEvent.time;
             
                totalTimeWaited+=0;
                totalIdleTime+=0; //no idle time as as soon as it arrives its served;
                totalServersAvailable--;
                serversIdle=totalServersAvailable;
                arrivalEvent.departureTime=generateDepartureTime(arrivalEvent.time);
                arrivalEvent.time=arrivalEvent.departureTime;
                cout<< "Process Arrival at time "<<arrivalEvent.arrivalTime<<endl;
                
                arrivalEvent.type=1;
                priorityQueue.insert(arrivalEvent);
                
               
            }
            
            if (priorityQueue.peekTop().type==0 && totalServersAvailable==0){

                Event arrivalEvent= priorityQueue.getTop();
                fifo.insert(arrivalEvent);
                time=arrivalEvent.time;
                cout<<"Process Arrival at time " << arrivalEvent.time<<endl;

            }
            if (priorityQueue.peekTop().type==1){

                Event departureEvent= priorityQueue.getTop();
                totalServersAvailable++;
                processesCompleted++;
                time=departureEvent.time;
                totalTimeInSystem+= departureEvent.departureTime - departureEvent.arrivalTime;
                serversIdle++;

                
                if (fifo.getSize()>0){

                    Event nextArrival=fifo.takeTop();
                    nextArrival.time=departureEvent.time;
                    totalTimeWaited+= departureEvent.time -nextArrival.arrivalTime;
                    nextArrival.time=generateDepartureTime(nextArrival.time);
                    nextArrival.type=1;
                    nextArrival.departureTime=nextArrival.time;
                    priorityQueue.insert(nextArrival);
                    totalServersAvailable--;
                    serversIdle--;

                }
                

            }
        }

     

    double percentIdle = (totalIdleTime / (time * totalServers)) * 100.0;
        cout<<"Percent Idel Time for the servers: "<< percentIdle<<"%"<<endl;

        cout<<"Average time in system: "<< totalTimeInSystem*M/numProcesses<<endl;
        cout<<"Average time waited: "<< totalTimeWaited/numProcesses<<endl;
        



        return 0;

     }
    